; This is a simple card trick where 21 cards are dealt into 3 columns
; of 7 cards each. The user picks a card and tells the computer which
; column the card is in. After a series of redeals, the computer displays
; the user's card without ever knowing which card it is -- just the column
; that it appears in with each redeal.

; Program written by Stan Munson (trollopite@hotmail.com).

; debug aid -- you'll find examples throughout the program

;MAKE "DEBUG? "TRUE
MAKE "DEBUG? "FALSE

TO DEBUG :LIST
IF :DEBUG? RUN :LIST
END

TO START.TRICK
MAKE "HAND.SIZE 21
MAKE "DEAL.DELAY 1000
MAKE "COLLECT.DELAY 400
MAKE "MOVE.DELAY 200
MAKE "MAX.PASSES 4
MAKE "SUITS [C D H S]
MAKE "RANKS [A 2 3 4 5 6 7 8 9 10 J Q K]
MAKE "RANK.NAMES [A ACE 2 TWO 3 THREE 4 FOUR 5 FIVE 6 SIX 7 SEVEN 8 EIGHT 9 NINE 10 TEN J JACK Q QUEEN K KING]
MAKE "SUIT.NAMES [C CLUBS D DIAMONDS H HEARTS S SPADES]
MAKE "ROWINC 30
MAKE "COLINC 90
MAKE "ANCHORXY [-90 90]
MAKE "DECKXY [-180 -90]
MAKE "COLUMN1 []
MAKE "COLUMN2 []
MAKE "COLUMN3 []
MAKE "MESSAGE1 "|Pick your secret card and tell me which column it is in.|
MAKE "MESSAGE2 "|Which column is your card in now?|
MAKE "MESSAGE3 "|And now which column?|
MAKE "SEQUENCE []
MAKE "DECK SHUFFLE NEWDECK
CLEARTEXT CLEARSCREEN HIDETURTLE
DECLARE "BITMAP "CARDBACK
ASK "CARDBACK [LOAD WORD "|~HOME/TOOLBOX/CARDS/BACK| RANDOM 8]
ASK "CARDBACK [SETXY :DECKXY]
CREATE.CARDS :DECK

DECLARE "STATICTEXT "INSTRUCT
PPROPS "INSTRUCT [
SIZE [100 50]
POSITION [200 90]
VISIBLE FALSE
]

DECLARE "RADIOBUTTON "INSTRUCT1
PPROPS "INSTRUCT1 [
SIZE [100 20]
POSITION [200 55]
TEXT |Left column|
VISIBLE FALSE
RUN [MAKE "SEQUENCE PICK [[COLUMN2 COLUMN1 COLUMN3] [COLUMN3 COLUMN1 COLUMN2]] COLLECT.CARDS]
]

DECLARE "RADIOBUTTON "INSTRUCT2
PPROPS "INSTRUCT2 [
SIZE [100 20]
POSITION [200 35]
TEXT |Middle column|
VISIBLE FALSE
RUN [MAKE "SEQUENCE PICK [[COLUMN1 COLUMN2 COLUMN3] [COLUMN3 COLUMN2 COLUMN1]] COLLECT.CARDS]
]

DECLARE "RADIOBUTTON "INSTRUCT3
PPROPS "INSTRUCT3 [
SIZE [100 20]
POSITION [200 15]
TEXT |Right column|
VISIBLE FALSE
RUN [MAKE "SEQUENCE PICK [[COLUMN1 COLUMN3 COLUMN2] [COLUMN2 COLUMN3 COLUMN1]] COLLECT.CARDS]
]

INFRONT "CARDBACK

DEMO.ROUTINE
MAKE.HAND
DEBUG [(SHOW "HAND: :HAND)]
MAKE "PASS 1
PLAY.TRICK
END

; Feel free to make up a different demo

TO DEMO.ROUTINE
LOCAL "SUIT
MAKE "SUIT PICK :SUITS
FOREACH :DECK [
IF EQUAL? CARD.SUIT "? :SUIT WAIT 200 MOVE "? [[-200 0] [0 100] [200 0] [0 -100]] "TRUE
]
WAIT 2000
FOREACH :DECK [MOVE "? LIST ASK "? [GETXY] :DECKXY "FALSE]
WAIT 2000
END

; Create the card bitmap objects

TO CREATE.CARDS :DECK
FOREACH :DECK [
DECLARE "BITMAP "?
; PPROP "? "VISIBLE "FALSE
ASK "? [LOAD WORD "|~home/toolbox/cards/| "?]
]
END

; Output a complete list of card names

TO NEWDECK
(LOCAL "DECK "SUIT "RANK)
MAKE "DECK []
FOR "SUIT 1 4 [
FOR "RANK 1 13 [
MAKE "DECK LPUT WORD (ITEM :SUIT :SUITS) (ITEM :RANK RANKS) :DECK
]
]
OUTPUT :DECK
END

; Output a list with elements randomly arranged

TO SHUFFLE :LIST
LOCAL "X
IF EMPTY? :LIST THEN OUTPUT []
MAKE "X RANDOM COUNT :LIST
OUTPUT FPUT ITEM :X :LIST SHUFFLE REMOVE.ITEM :X :LIST 
END

; Output a new word or list with a specific item removed

TO REMOVE.ITEM :N :WORL
IF WORD? :WORL THEN OUTPUT REMOVE.LETTER :N :WORL
OUTPUT REMOVE.ELEMENT :N :WORL
END

TO REMOVE.ELEMENT :N :LIST
IF .LT :N 2 THEN OUTPUT BUTFIRST :LIST
OUTPUT SENTENCE (FIRST :LIST) (REMOVE.ELEMENT (:N - 1) (BUTFIRST :LIST))
END

TO REMOVE.LETTER :N :WORD
IF .LT :N 2 THEN OUTPUT BUTFIRST :WORD
OUTPUT WORD (FIRST :WORD) (REMOVE.LETTER (:N - 1) (BUTFIRST :WORD))
END

TO MAKE.HAND
MAKE "HAND []
REPEAT :HAND.SIZE [
MAKE "HAND LPUT FIRST :DECK :HAND
MAKE "DECK BUTFIRST :DECK
]
FOREACH :HAND [PPROP "? "VISIBLE "TRUE]
DEBUG [SHOW [IN MAKE.HAND:]]
DEBUG [(SHOW "HAND: :HAND)]
DEBUG [(SHOW "DECK: :DECK)]
DEBUG [SHOW [EXITING MAKE.HAND:]] 
END

TO PLAY.TRICK
DEAL.HAND
GET.COLUMN
END

TO DEAL.HAND
MAKE "COLUMN1 []
MAKE "COLUMN2 []
MAKE "COLUMN3 []
(LOCAL "ROW "COL "TOPCARD)
WAIT :DEAL.DELAY
FOR "ROW 0 6 [
FOR "COL 0 2 [
MAKE "TOPCARD FIRST :HAND
MAKE "HAND BUTFIRST :HAND
MAKE WORD "COLUMN (:COL + 1) LPUT :TOPCARD THING WORD "COLUMN (:COL + 1)
INFRONT :TOPCARD
MOVE :TOPCARD LIST :DECKXY NEXTXY "FALSE
]
]
INFRONT "CARDBACK
DEBUG [(SHOW "HAND: :HAND)]
DEBUG [(SHOW "COLUMNS: :COLUMN1 :COLUMN2 :COLUMN3)]
END

TO NEXTXY
OUTPUT LIST ((FIRST :ANCHORXY) + (:COLINC * :COL)) ((LAST :ANCHORXY) - (:ROWINC * :ROW))
END

TO GET.COLUMN
PPROP "INSTRUCT "TEXT THING WORD "MESSAGE :PASS
FOREACH [INSTRUCT1 INSTRUCT2 INSTRUCT3] [
PPROP "? "STATE "FALSE]
FOREACH [INSTRUCT INSTRUCT1 INSTRUCT2 INSTRUCT3] [
PPROP "? "VISIBLE "TRUE]
END

TO COLLECT.CARDS
FOREACH [INSTRUCT INSTRUCT1 INSTRUCT2 INSTRUCT3] [
PPROP "? "VISIBLE "FALSE]
REMAKE.HAND
MAKE "PASS :PASS + 1
IF EQUAL? :PASS :MAX.PASSES THEN END.GAME ELSE PLAY.TRICK
END

TO REMAKE.HAND
DEBUG [SHOW [IN REMAKE.HAND]]
DEBUG [(SHOW "HAND: :HAND)]
FOREACH :SEQUENCE [
MAKE "HAND SENTENCE :HAND THING "?
MOVE.CARDS THING "?
WAIT :COLLECT.DELAY
]
DEBUG [(SHOW "HAND: :HAND)]
DEBUG [SHOW [EXITING REMAKE.HAND]]
END

TO MOVE.CARDS :COLUMN
FOREACH :COLUMN [
ASK "? [MOVE "? (LIST ASK "? [GETXY] :DECKXY) "FALSE]
]
END

TO END.GAME
(LOCAL "SECRET "ANSWER)
DEBUG [SHOW [IN END.GAME:]]
DEBUG [(SHOW "DECK: :DECK)]
DEBUG [SHOW COUNT :DECK]
DEBUG [(SHOW "HAND: :HAND)]
DEBUG [SHOW [EXITING END.GAME:]]
MAKE "SECRET ITEM 11 :HAND
MAKE "DECK SHUFFLE SENTENCE :DECK :HAND
MAKE "HAND []
WHILE [NOT EQUAL? ASK :SECRET [GETXY] :DECKXY] [] 
ASK :SECRET [SETXY [0 0] SETTSIZE 2.5]
WAIT 3000
MAKE "ANSWER (ALERT "|Want to play again?| "YES "NO)
ASK :SECRET [SETXY :DECKXY SETTSIZE 1]
IF EQUAL? :ANSWER "YES THEN \
MAKE "PASS 1 MAKE.HAND PLAY.TRICK \
ELSE \
52PICKUP WAIT 1000 \
COMMAND FINDMENUID "DEBUG "|restart logo| \
PRINT [|Use WHERE'S.WALDO? (alias WW) to find more cards.|]
PRINT WHERE'S.WALDO?
END

; Translate card name to text message

TO CARD.TEXT :CARD
OUTPUT LOWERCASE (WORD RANK.NAME :CARD "| of | SUIT.NAME :CARD)
END

TO CARD.RANK :CARD
OUTPUT BUTFIRST :CARD
END

TO CARD.SUIT :CARD
OUTPUT FIRST :CARD
END

TO SUIT.NAME :CARD
OUTPUT FIRST BUTFIRST FROMMEMBER CARD.SUIT :CARD :SUIT.NAMES
END

TO RANK.NAME :CARD
OUTPUT FIRST BUTFIRST FROMMEMBER CARD.RANK :CARD RANK.NAMES
END

; Examples from the Tutorial for putting objects in front of others
; or in back of others

TO INFRONT :OBJECT
PPROP :OBJECT "Z.ORDER 0
END

TO INBACK :OBJECT
PPROP OBJECT "Z.ORDER COUNT EVERY "BITMAP
END

; Procedures for moving a turtle through a user-supplied path of coordinates.
;
; MOVE causes a turtle to move from point to point as supplied in a 
; list of coordinates which can result in a very complicated movement.
;
; To invoke, type MOVE and give it the turtle number or name, the list
; of coordinate points and either "TRUE (if you want the turtle to move
; forever) or "FALSE (if you want the turtle to stop at the last point).
;
; To test if a turtle is already moving, use MOVING? with the turtle
; number or name. It returns "TRUE if the turtle is moving and "FALSE
; if it is not.
;
; To stop the turtle movement, use STOP.MOVING with the turtle number
; or name.

TO MOVE :TURTLE :PATH :FOREVER?
IF MOVING? :TURTLE THEN STOP.MOVING :TURTLE
PPROP :TURTLE "MOVE.PATH :PATH
PPROP :TURTLE "MOVE.FOREVER? :FOREVER?
PPROP :TURTLE "MOVE.ID LAUNCH LIST "MOVEMENT QUOTE (:TURTLE)
END

TO MOVING? :TURTLE
OUTPUT NOT EMPTY? GPROP :TURTLE "MOVE.ID
END

TO STOP.MOVING :TURTLE
IF NOT MOVING? :TURTLE THEN STOP
LOCAL "ID
MAKE "ID GPROP :TURTLE "MOVE.ID
REMPROP :TURTLE "MOVE.PATH
REMPROP :TURTLE "MOVE.FOREVER?
REMPROP :TURTLE "MOVE.ID
(HALT :ID)
END

TO MOVEMENT :TURTLE
(LOCAL "POINT "MAXPOINTS "NEXTPOINT "PATH "PENSTATE)
MAKE "PATH GPROP :TURTLE "MOVE.PATH
MAKE "MAXPOINTS COUNT :PATH
MAKE "POINT :MAXPOINTS
ASK :TURTLE [
MAKE "PENSTATE LIST PEN PENCOLOR
PENUP SETXY FIRST :PATH
SETPEN :PENSTATE]
WHILE ["TRUE] [
MAKE "POINT 1 + REMAINDER :POINT :MAXPOINTS 
MAKE "NEXTPOINT ITEM :POINT :PATH 
ASK :TURTLE [SETH TOWARDS :NEXTPOINT] 
WHILE [NOT EQUAL? ASK :TURTLE [GETXY] :NEXTPOINT] [
ASK :TURTLE [FD 1]] 
  IF END.OF.MOVING? THEN STOP.MOVING :TURTLE STOP 
]
END

TO END.OF.MOVING?
OUTPUT AND (EQUAL? :POINT :MAXPOINTS) (EQUAL? "FALSE GPROP :TURTLE "MOVE.FOREVER?)
END

; Another simple game?

TO 52PICKUP
FOREACH :DECK [
ASK "? [
SETXY LIST ((RANDOM 250) * (PICK [1 -1])) ((RANDOM 90) * (PICK [1 -1]))
]
]
END

; Another simple game?

TO WHERE'S.WALDO?
OUTPUT (WORD "|Where's the | CARD.TEXT PICK :DECK "?)
END

ALIAS WHERE'S.WALDO? "WW

START.TRICK
